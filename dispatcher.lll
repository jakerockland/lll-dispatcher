;;; ---------------------------------------------------------------------------
;;; @title A contract function dispatcher.
;;; @author Daniel Ellison <daniel@syrinx.net>
;;;
;;; Copyright 2016, 2017 Daniel Ellison
;;;
;;;    Licensed under the Apache License, Version 2.0 (the "License");
;;;    you may not use this file except in compliance with the License.
;;;    You may obtain a copy of the License at
;;;
;;;      http://www.apache.org/licenses/LICENSE-2.0
;;;
;;;    Unless required by applicable law or agreed to in writing, software
;;;    distributed under the License is distributed on an "AS IS" BASIS,
;;;    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;;    See the License for the specific language governing permissions and
;;;    limitations under the License.

(seq

  ;; --------------------------------------------------------------------------
  ;; INIT

  ;; Bring in our macro definitions.
  (include "stdlib/stdlib.lll")
  (include "macros.lll")

  ;; Make sure we're working with the right standard library version.
  (when (!= stdlib-version required-stdlib)
    (panic))

  ;; Save the caller as the contract owner for use by modifiers.
  (sstore contract-owner (caller))

  ;; Grab the constructor parameter and do a simple check to ensure that
  ;; something was actually provided.
  (codecopy scratch-one (bytecodesize) 32)
  (when (= @scratch-one 0x00)
    (panic))

  ;; Store the constructor parameter and enable the contract.
  (sstore contract-address @scratch-one)
  (sstore @@contract-address true)

  ;; Call the contract's initialize() function, making sure the call succeeds.
  ;; A failure will abort contract deployment. This is one way to guarantee
  ;; that a valid contract address was provided.
  (mstore call-data (shift-left initialize))
  (when (= false (delegatecall (- (gas) hold-back) @@contract-address
      call-data 32 return-data 0))
    (panic))

  ;; --------------------------------------------------------------------------
  ;; CODE

  (returnlll
    (seq

      ;; ----------------------------------------------------------------------
      ;; First, retrieve and store the return size of the function to be called
      ;; (the function's ID is in the first four bytes of the call data). Then
      ;; copy all call data to a known location. Finally, call the contract,
      ;; recording the return code of the called function.

      (mstore return-size (get-return-size (calldataload 0)))
      (calldatacopy call-data 0x00 (calldatasize))
      (mstore return-code (delegatecall (- (gas) hold-back) @@contract-address
          call-data (calldatasize) return-data @return-size))

      ;; ----------------------------------------------------------------------
      ;; If the delegatecall failed, propagate the failure up by causing an EVM
      ;; exception. If the call was successful, relay the data returned from
      ;; the call, making sure to include the right length of data. If there's
      ;; no return data, just end contract execution.

      (if (= false @return-code)
        (panic)
        (if (!= @return-size 0)
          (return return-data @return-size)
          (stop)))))

)

;;; ---------------------------------------------------------------------------
;;; @title A contract function dispatcher.
;;; @author Daniel Ellison <daniel@syrinx.net>
;;;
;;; Copyright 2016, 2017 Daniel Ellison
;;;
;;;    Licensed under the Apache License, Version 2.0 (the "License");
;;;    you may not use this file except in compliance with the License.
;;;    You may obtain a copy of the License at
;;;
;;;      http://www.apache.org/licenses/LICENSE-2.0
;;;
;;;    Unless required by applicable law or agreed to in writing, software
;;;    distributed under the License is distributed on an "AS IS" BASIS,
;;;    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;;    See the License for the specific language governing permissions and
;;;    limitations under the License.

(seq

  ;; --------------------------------------------------------------------------
  ;; CONSTRUCTOR

  ;; Bring in our macro definitions.
  (include "stdlib/stdlib.lll")
  (include "macros.lll")

  ;; Make sure we're working with the right standard library version.
  (when (!= stdlib-version required-stdlib)
    (jump invalid-location))

  ;; Save the caller for use by modifiers.
  (sstore contract-owner (caller))

  ;; Grab the constructor parameter.
  (codecopy scratch-one (bytecodesize) 32)

  ;; Make sure a contract address was provided.
  (when (= @scratch-one 0x00)
    (jump invalid-location))

  ;; Store the associated contract address and enable the contract.
  (sstore contract-address @scratch-one)
  (sstore @@contract-address true)

  ;; Call the contract's initialize() function.
  (mstore call-data (shift-left initialize))
  (when (= false (delegatecall (- (gas) hold-back) @@contract-address
      call-data 32 return-data 0))
    (jump invalid-location))

  ;; --------------------------------------------------------------------------
  ;; CONTRACT CODE

  (returnlll
    (seq

      ;; ----------------------------------------------------------------------
      ;; First, store the short hash of the function to be called (for use by
      ;; the 'return-size' macro). Then copy all calldata to a known location.
      ;; Finally, call the contract @@contract-address providing the function
      ;; call return length.

      (mstore short-hash (shift-right (calldataload 0)))
      (calldatacopy call-data 0x00 (calldatasize))
      (mstore return-code (delegatecall (- (gas) hold-back) @@contract-address
          call-data (calldatasize) return-data return-size))

      ;; ----------------------------------------------------------------------
      ;; If the call was successful, relay the data returned from the call,
      ;; making sure we include the right length of data. If there's no return
      ;; data, just end contract execution. If delegatecall failed, we
      ;; propagate the EVM exception up.

      (if (= @return-code true)
        (if (!= return-size 0)
          (return return-data return-size)
          (stop))
        (jump invalid-location))))

)
